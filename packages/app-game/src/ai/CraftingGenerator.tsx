import { ILanguageModelContext } from "@siocode/base";
import { IWorldItem } from "../context/World.context";
import { WORLD_ITEM_TIER_DISPLAYS, WORLD_ITEM_TYPE_DESCRIPTIONS, WORLD_ITEM_TYPE_DISPLAYS, WORLD_PLAYER_CRAFTING_TYPE_DESCRIPTIONS, WORLD_PLAYER_CRAFTING_TYPE_DISPLAYS, WorldPlayerCraftingType } from "../model/world.enums";
import { shuffleArray } from "../utils/shuffleArray";
import { IAITask } from "./AITask";

export interface ICraftingRequest {
    ingredients: Array<IWorldItem>;
    tools: Array<IWorldItem>;
    craftingType: WorldPlayerCraftingType;
    resultPrototypes: Array<IWorldItem>;
}

export interface ICraftingResponse {
    items: Array<IWorldItem>;
}

const SYSTEM_PROMPT = `Your task is to simulate the input crafting, and generate the details of the pre-determined output items. Be realistic, and take into consideration the type of crafting, ingredients used, and tools utilized. Fill the details of exactly the results pre-generated by the RNG algorithm. Your response must start with 'I propose the following crafting output: '.`;

const EXAMPLES = [
    {
        ingredients: [
            { type: "household", name: "Crooked Mug", tier: "common" }
        ],
        craftingType: "break",
        tools: [],
        prototypes: [
            { item: 0, name: "Material created by breaking Crooked Mug", tier: "garbage", type: "material" },
            { item: 1, name: "Household created by breaking Crooked Mug", tier: "common", type: "household" }
        ],
        expected: [
            { item: 0, name: "Ceramic Shard" },
            { item: 1, name: "Mug Handle" }
        ]
    },
    {
        ingredients: [
            { type: "household", name: "Salt", tier: "common" },
            { type: "food", name: "Bread", tier: "common" },
            { type: "household", name: "Fresh Butter", tier: "common" }
        ],
        craftingType: "cook",
        tools: [],
        prototypes: [
            { item: 0, name: "Food created by cooking Salt, Bread, Fresh Butter", tier: "common", type: "food" }
        ],
        expected: [
            { item: 0, name: "Salted Butter Bread" }
        ]
    },
    {
        ingredients: [
            { type: "household", name: "Stick", tier: "common" }
        ],
        craftingType: "refine",
        tools: [
            { type: "weapon", name: "Rusty Butcher's Knife", tier: "common" }
        ],
        prototypes: [
            { item: 0, name: "Weapon created by refining Stick", tier: "common", type: "weapon" },
            { item: 1, name: "Material created by refining Stick", tier: "garbage", type: "material" }
        ],
        expected: [
            { item: 0, name: "Sharpened Stick" },
            { item: 1, name: "Wooden Splinter" }
        ]
    },
    {
        ingredients: [
            { type: "weapon", name: "Iron Sword", tier: "common" },
            { type: "material", name: "Cloth", tier: "common" }
        ],
        craftingType: "refine",
        tools: [],
        prototypes: [
            { item: 0, name: "Weapon refined from Iron Sword, Cloth", tier: "common", type: "weapon" }
        ],
        expected: [
            { item: 0, name: "Polished Iron Sword" }
        ]
    },
    {
        ingredients: [
            { type: "boots", name: "Dragonscale Boots", tier: "epic" },
            { type: "material", name: "Enchanted Stone", tier: "rare" }
        ],
        craftingType: "refine",
        tools: [
            { type: "household", name: "Tome of Spells", tier: "common" }
        ],
        prototypes: [
            { item: 0, name: "Boots refined from Dragonscale Boots, Enchanted Stone using Tome of Spells", tier: "legendary", type: "boots" }
        ],
        expected: [
            { item: 0, name: "Aegor's Boots" }
        ]
    },
    {
        ingredients: [
            { type: "material", name: "Gold Ore", tier: "rare" },
            { type: "material", name: "Dragon Charcoal", tier: "rare" }
        ],
        craftingType: "smelt",
        tools: [
            { type: "furnace", name: "Ancient Forge", tier: "epic" }
        ],
        prototypes: [
            { item: 0, name: "Metal created by smelting Gold Ore, Dragon Charcoal", tier: "epic", type: "metal" }
        ],
        expected: [
            { item: 0, name: "Molten Gold Ingot" }
        ]
    },
    {
        ingredients: [
            { type: "material", name: "Crystal Orb", tier: "legendary" },
            { type: "material", name: "Ruby of Flame", tier: "legendary" }
        ],
        craftingType: "assemble",
        tools: [
            { type: "household", name: "Arcane Workbench", tier: "legendary" }
        ],
        prototypes: [
            { item: 0, name: "Artifact created by assembling Crystal Orb, Ruby of Flame", tier: "legendary", type: "material" }
        ],
        expected: [
            { item: 0, name: "Orb of Eternal Inferno" }
        ]
    },
    {
        ingredients: [
            { type: "weapon", name: "Iron Buckler", tier: "common" },
            { type: "material", name: "Amethyst Shard", tier: "rare" }
        ],
        craftingType: "refine",
        tools: [],
        prototypes: [
            { item: 0, name: "Shield refined from Iron Buckler, Amethyst Shard", tier: "rare", type: "weapon" }
        ],
        expected: [
            { item: 0, name: "Amethyst-Embedded Buckler" }
        ]
    },
    {
        ingredients: [
            { type: "weapon", name: "Crossbow", tier: "rare" },
            { type: "material", name: "Runic Wood", tier: "epic" }
        ],
        craftingType: "refine",
        tools: [
            { type: "household", name: "Master Carpenter's Bench", tier: "epic" }
        ],
        prototypes: [
            { item: 0, name: "Weapon refined from Crossbow, Runic Wood", tier: "epic", type: "weapon" }
        ],
        expected: [
            { item: 0, name: "Runebolt Crossbow" }
        ]
    },
    {
        ingredients: [
            { type: "consumable", name: "Healing Elixir", tier: "rare" },
            { type: "material", name: "Moonwater Essence", tier: "epic" }
        ],
        craftingType: "assemble",
        tools: [
            { type: "household", name: "Alchemist's Kit", tier: "rare" }
        ],
        prototypes: [
            { item: 0, name: "Potion created by mixing Healing Elixir, Moonwater Essence", tier: "epic", type: "consumable" }
        ],
        expected: [
            { item: 0, name: "Elixir of Lunar Restoration" }
        ]
    },
    {
        ingredients: [
            { type: "armor", name: "Leather Jerkin", tier: "common" },
            { type: "material", name: "Wolfhide", tier: "rare" }
        ],
        craftingType: "assemble",
        tools: [],
        prototypes: [
            { item: 0, name: "Armor assembled from Leather Jerkin, Wolfhide", tier: "rare", type: "armor" }
        ],
        expected: [
            { item: 0, name: "Wolfhide Jerkin" }
        ]
    },
];


export class CraftingGenerator implements IAITask<ICraftingRequest, ICraftingResponse> {
    constructor(
        private lm: ILanguageModelContext
    ) {

    }

    get name() {
        return "Crafting";
    }

    getPromptFor(input: ICraftingRequest): { messages: Array<{ role: "system" | "user" | "assistant"; content: string; }>; nextMessage: string; } {

        const exMsgs = [];
        const examples = shuffleArray(EXAMPLES);

        for (const example of examples) {
            let exampleUserMsg = `Crafting Type: ${WORLD_PLAYER_CRAFTING_TYPE_DISPLAYS[example.craftingType]} - ${WORLD_PLAYER_CRAFTING_TYPE_DESCRIPTIONS[example.craftingType]}\n`;
            for (const ingredient of example.ingredients) {
                exampleUserMsg += `Ingredient: ${ingredient.name} [${WORLD_ITEM_TIER_DISPLAYS[ingredient.tier]}] (${WORLD_ITEM_TYPE_DISPLAYS[ingredient.type]} - ${WORLD_ITEM_TYPE_DESCRIPTIONS[ingredient.type]})\n`;
            }
            for (const tool of example.tools) {
                exampleUserMsg += `Tool: ${tool.name} [${WORLD_ITEM_TIER_DISPLAYS[tool.tier]}] (${WORLD_ITEM_TYPE_DISPLAYS[tool.type]} - ${WORLD_ITEM_TYPE_DESCRIPTIONS[tool.type]})\n`;
            }
            for (const proto of example.prototypes) {
                exampleUserMsg += `Prototype ${proto.item}: ${proto.name} [${WORLD_ITEM_TIER_DISPLAYS[proto.tier]}] (${WORLD_ITEM_TYPE_DISPLAYS[proto.type]} - ${WORLD_ITEM_TYPE_DESCRIPTIONS[proto.type]})\n`;
            }
            exampleUserMsg += `Number of Prototypes: ${example.prototypes.length}`;
            exMsgs.push({
                role: "user",
                content: exampleUserMsg.trim()
            });
            let exampleAssistantMsg = `I propose the following crafting output:\n`;
            for (const exp of example.expected) {
                exampleAssistantMsg += `${exp.item} => ${exp.name}\n`;
            }
            exMsgs.push({
                role: "assistant",
                content: exampleAssistantMsg.trim()
            });
        }

        let nowUserMsg = `Crafting Type: ${WORLD_PLAYER_CRAFTING_TYPE_DISPLAYS[input.craftingType]} - ${WORLD_PLAYER_CRAFTING_TYPE_DESCRIPTIONS[input.craftingType]}\n`;
        for (const ingredient of input.ingredients) {
            nowUserMsg += `Ingredient: ${ingredient.name} [${WORLD_ITEM_TIER_DISPLAYS[ingredient.tier]}] (${WORLD_ITEM_TYPE_DISPLAYS[ingredient.type]} - ${WORLD_ITEM_TYPE_DESCRIPTIONS[ingredient.type]})\n`;
        }
        for (const tool of input.tools) {
            nowUserMsg += `Tool: ${tool.name} [${WORLD_ITEM_TIER_DISPLAYS[tool.tier]}] (${WORLD_ITEM_TYPE_DISPLAYS[tool.type]} - ${WORLD_ITEM_TYPE_DESCRIPTIONS[tool.type]})\n`;
        }
        for (const [index, proto] of input.resultPrototypes.entries()) {
            nowUserMsg += `Prototype ${index}: ${proto.name} [${WORLD_ITEM_TIER_DISPLAYS[proto.tier]}] (${WORLD_ITEM_TYPE_DISPLAYS[proto.type]} - ${WORLD_ITEM_TYPE_DESCRIPTIONS[proto.type]})\n`;
        }
        nowUserMsg += `Number of Prototypes: ${input.resultPrototypes.length}`;

        return {
            messages: [
                {
                    role: "system",
                    content: SYSTEM_PROMPT
                },
                ...exMsgs
            ],
            nextMessage: nowUserMsg.trim()
        };

    }

    async prompt(request) {
        const result = {
            items: []
        };

        const inPrompt = this.getPromptFor(request);

        while (true) {

            const llm = await this.lm.create(inPrompt.messages);
            let resultText = await llm.prompt(inPrompt.nextMessage);

            if (resultText.startsWith("I propose the following crafting output:")) {
                resultText = resultText.replace("I propose the following crafting output:", "").trim();
            } else {
                console.warn("[CraftingGenerator]", "Invalid response format", resultText);
                continue;
            }

            resultText = resultText.trim();
            const resultLines = resultText.split("\n");

            const aiItems = [];

            for (let [index, line] of resultLines.entries()) {
                const parts = line.split("=>").map(p => p.trim());
                if (parts.length === 2) {
                    aiItems.push({
                        item: index,
                        name: parts[1]
                    });
                } else {
                    console.warn("[CraftingGenerator]", "Invalid line format", line);
                }
            }

            aiItems.sort((a, b) => a.item - b.item);

            console.log("[CraftingGenerator]", "AI Items", aiItems);

            if (aiItems.length !== request.resultPrototypes.length) {
                console.warn("[CraftingGenerator]", "Invalid item count", aiItems.length, request.resultPrototypes.length, resultText);
                continue;
            }

            for (let [index, proto] of request.resultPrototypes.entries()) {
                result.items.push({
                    ...proto,
                    name: aiItems[index].name
                });
            }

            break;

        }

        return result;
    }
}