{
    "map": {
        "populators": "game-worldgen-populators",
        "rules": "game-worldgen-rules",
        "populator-collections": "game-worldgen-populator-collections",
        "rule-collections": "game-worldgen-rule-collections",
        "enums": "world-enums"
    },
    "filename": "projor-debug.txt"
}
---
You are responsible for extending the game called `The Crooked Tankard`.

The game can be extended with new **populators** and **rules**.

You will be given a broad context of interfaces and enumerations. Only output data adhering to these structures, and make sure to only ever use enum values that are actually defined!


export interface IWorldItemDetails {
  description: string;
}

export interface IWearableItemEffect {
  name: string;
  details?: any;
  type: WorldWearableEffectType;
  activation: WorldWearableEffectActivation;
  value?: number;
}

export interface IConsumableItemEffect {
  name: string;
  details?: any;
  type: WorldConsumableEffectType;
  value?: number;
}

export interface IWorldItemWeaponCharacteristics {
  weaponType: WorldWeaponType;
  damage: number;
  effects?: Array<IWearableItemEffect>;
}

export interface IWorldItemArmorCharacteristics {
  defense: number;
  effects?: Array<IWearableItemEffect>;
}

export interface IWorldItemBootsCharacteristics {
  defense: number;
  effects?: Array<IWearableItemEffect>;
}

export interface IWorldItemHelmetCharacteristics {
  defense: number;
  effects?: Array<IWearableItemEffect>;
}

export interface IWorldItemWearableCharacteristics {
  wearableType: WorldWearableType;
  defense: number;
  effects?: Array<IWearableItemEffect>;
}

export interface IWorldItemConsumableCharacteristics {
  effects: Array<IConsumableItemEffect>;
}

export interface IWorldItem {
  id: number;
  name: string;
  type: WorldItemType;
  tier: WorldItemTier;
  labels: Array<string>;
  details?: IWorldItemDetails;
  contains?: Array<IWorldItem>;
  static?: boolean;
  destroyed?: boolean;
  weapon?: IWorldItemWeaponCharacteristics;
  armor?: IWorldItemArmorCharacteristics;
  boots?: IWorldItemBootsCharacteristics;
  helmet?: IWorldItemHelmetCharacteristics;
  wearable?: IWorldItemWearableCharacteristics;
  consumable?: IWorldItemConsumableCharacteristics;
  lootable?: boolean;
}

export interface ICharacterInventory {
  gold: number;
  items: Array<IWorldItem>;
}

export interface ICharacterGear {
  armor?: IWorldItem | null;
  boots?: IWorldItem | null;
  helmet?: IWorldItem | null;
  weapon?: IWorldItem | null;
  wearable?: IWorldItem | null;
}

export interface INonPlayerCharacterPersonality {
  traits: Array<WorldNpcPersonalityTrait>;
  background: WorldNpcBackground;
}

export interface ICharacterHealth {
  status: WorldPlayerHealth;
  points: number;
  max: number;
}

export interface IKnowledge {
  item?: IWorldItem;
  itemLocation?: IWorldNode;
  location?: IWorldNode;
  npc?: INonPlayerCharacter;
  npcLocation?: IWorldNode;
  distance?: number;
}

export interface IWorldNodeMatcher {
  node?: IWorldNode;
  type?: WorldNodeAreaType;
  wilderness?: { wildernessType: WorldNodeWildernessType };
  settlement?: { settlementType: WorldNodeSettlementType };
  building?: { buildingType: WorldNodeBuildingType };
  room?: { roomType: WorldNodeRoomType };
  street?: { streetType: WorldNodeStreetType };
  labels?: Array<string>;
}

export interface IWorldItemMatcher {
  item?: IWorldItem;
  type?: WorldItemType;
  tier?: WorldItemTier;
  weapon?: { weaponType: WorldWeaponType };
  wearable?: { wearableType: WorldWearableType };
  labels?: Array<string>;
}

export interface INonPlayerCharacterMatcher {
  npc?: INonPlayerCharacter;
  race?: WorldNpcRace;
  stance?: WorldNpcStance;
  labels?: Array<string>;
  personality?: {
      traits?: Array<WorldNpcPersonalityTrait>;
      background?: WorldNpcBackground;
  }
}

export interface IDeliverQuestCharacteristics {
  item: IWorldItem;
  recipient: INonPlayerCharacter;
}

export interface ICollectQuestCharacteristics {
  items: Array<IWorldItemMatcher>;
}

export interface IFindLocationQuestCharacteristics {
  location: IWorldNode;
}

export interface ITalkToQuestCharacteristics {
  npc: INonPlayerCharacter;
}

export interface IKillQuestCharacteristics {
  npc: INonPlayerCharacter;
}

export interface IQuest {
  type: WorldNpcQuestType;
  deliver?: IDeliverQuestCharacteristics;
  collect?: ICollectQuestCharacteristics;
  findLocation?: IFindLocationQuestCharacteristics;
  talkTo?: ITalkToQuestCharacteristics;
  kill?: IKillQuestCharacteristics;
}

export interface IPossibleQuest {
  type: WorldNpcQuestType;
  deliver?: {
      item: IWorldItemMatcher;
      recipient: INonPlayerCharacterMatcher;
  }
  collect?: {
      items: Array<IWorldItemMatcher>;
  }
  findLocation?: {
      location: IWorldNodeMatcher;
  }
  talkTo?: {
      npc: INonPlayerCharacterMatcher;
  }
  kill?: {
      npc: INonPlayerCharacterMatcher;
  }
}

export interface INonPlayerCharacter {
  id: number;
  name: string;
  race: WorldNpcRace;
  labels: Array<string>;
  location: IWorldNode;
  stance: WorldNpcStance;
  health: ICharacterHealth;
  inventory?: ICharacterInventory;
  gear?: ICharacterGear;
  personality?: INonPlayerCharacterPersonality;
  knowledge?: Array<IKnowledge>;
  activeQuests?: Array<IQuest>;
  possibleQuests?: Array<IPossibleQuest>;
}

export interface IWorldHierarchyNode {
  name: string;
  level?: WorldNodeLevel;
}

export interface IWorldNodeBuilding {
  buildingType: WorldNodeBuildingType;
}

export interface IWorldNodeRoom {
  roomType: WorldNodeRoomType;
}

export interface IWorldNodeStreet {
  streetType: WorldNodeStreetType;
}

export interface IWorldNodeSettlement {
  settlementType: WorldNodeSettlementType;
}

export interface IWorldNodeWilderness {
  wildernessType: WorldNodeWildernessType;
}

export interface IWorldNode {
  id: number;
  name: string;
  type: WorldNodeAreaType;
  level?: WorldNodeLevel;
  temperature: WorldNodeTemperature;
  humidity: WorldNodeHumidity;
  labels: Array<string>;
  outEdges: Array<IWorldEdge>;
  details?: IWorldNodeDetails;
  hierarchy: Array<IWorldHierarchyNode>;
  items?: Array<IWorldItem>;
  npcs?: Array<INonPlayerCharacter>;
  building?: IWorldNodeBuilding;
  room?: IWorldNodeRoom;
  street?: IWorldNodeStreet;
  settlement?: IWorldNodeSettlement;
  wilderness?: IWorldNodeWilderness;
  ancestor?: IWorldNode;
}

export interface IWorldEdge {
  id: number;
  from: IWorldNode;
  to: IWorldNode;
  distance: number;
  labels: Array<string>;
  discovered: boolean;
}

export interface IPlayerSkills {
  skills: Array<WorldPlayerSkill>;
}

export interface IPlayerHunger {
  status: WorldPlayerHunger;
  lastMealTime: number;
  lastMeal: IWorldItem | null;
}

export interface IPlayerThirst {
  status: WorldPlayerThirst;
  lastDrinkTime: number;
  lastDrink: IWorldItem | null;
}

export interface IPlayerCharacter {
  name: string;
  characterClass: WorldPlayerClass;
}

{{#each enums}}
// {{{description}}}
enum World{{{pascalCase name}}}
{{#each values}}
    {{{kebabCase name}}} // {{{description}}}
{{/each}}

{{/each}}


export type NodePopulatorType =
  | "children"
  | "item"
  | "npc";

export interface INodeChildrenPopulator {
  id: string;
  populatorType: "children";
  type: WorldNodeAreaType | Array<WorldNodeAreaType>;
  name: string;
  building?: {
    buildingType: WorldNodeBuildingType | Array<WorldNodeBuildingType>;
  };
  room?: {
    roomType: WorldNodeRoomType | Array<WorldNodeRoomType>;
  };
  street?: {
    streetType: WorldNodeStreetType | Array<WorldNodeStreetType>;
  };
  settlement?: {
    settlementType: WorldNodeSettlementType | Array<WorldNodeSettlementType>;
  };
  wilderness?: {
    wildernessType: WorldNodeWildernessType | Array<WorldNodeWildernessType>;
  };
  temperature: "same" | WorldNodeTemperature | Array<WorldNodeTemperature>;
  humidity: "same" | WorldNodeHumidity | Array<WorldNodeHumidity>;
  distance: number | Array<number>;
  labels?: Array<string>;
}

export type INodeItemWearableEffectSpec = {
  name: string | Array<string>;
  type: WorldWearableEffectType | Array<WorldWearableEffectType>;
  activation: WorldWearableEffectActivation | Array<WorldWearableEffectActivation>;
  value?: number | Array<number>;
  probability?: number;
}

export type INodeItemConsumableEffectSpec = {
  name: string | Array<string>;
  type: WorldConsumableEffectType | Array<WorldConsumableEffectType>;
  value?: number | Array<number>;
  probability?: number;
}

export interface INodeItemSpec {
  type: WorldItemType | Array<WorldItemType>;
  tier: WorldItemTier | Array<WorldItemTier>;
  name: string | Array<string>;
  noAi?: boolean;
  weapon?: {
    weaponType: WorldWeaponType | Array<WorldWeaponType>;
    damage: {
      min: number;
      max: number;
    };
    effects?: Array<INodeItemWearableEffectSpec>;
  };
  armor?: {
    defense: {
      min: number;
      max: number;
    };
    effects?: Array<INodeItemWearableEffectSpec>;
  };
  wearable?: {
    wearableType: WorldWearableType | Array<WorldWearableType>;
    defense: {
      min: number;
      max: number;
    };
    effects?: Array<INodeItemWearableEffectSpec>;
  };
  helmet?: {
    defense: {
      min: number;
      max: number;
    };
    effects?: Array<INodeItemWearableEffectSpec>;
  };
  boots?: {
    defense: {
      min: number;
      max: number;
    };
    effects?: Array<INodeItemWearableEffectSpec>;
  };
  consumable?: {
    effects: Array<INodeItemConsumableEffectSpec>;
  };
  static?: boolean;
  probability?: number;
  contains?: Array<INodeItemSpec>;
  lootable?: boolean;
  oneOf?: Array<INodeItemSpec> | Array<string>;
  labels?: Array<string>;
}

export interface INodeItemPopulator extends INodeItemSpec {
  id: string;
  populatorType: "item";
}

export interface INodeNpcPopulator {
  id: string;
  populatorType: "npc";
  name: string | Array<string>;
  race: WorldNpcRace | Array<WorldNpcRace>;
  stance: WorldNpcStance | Array<WorldNpcStance>;
  health: {
    status: WorldPlayerHealth | Array<WorldPlayerHealth>;
    points: number | Array<number>;
    max: number | Array<number>;
  }
  inventory?: {
    gold?: number | Array<number>;
    items?: Array<INodeItemSpec> | Array<string>;
  };
  gear?: {
    armor?: INodeItemSpec | string | null;
    helmet?: INodeItemSpec | string | null;
    boots?: INodeItemSpec | string | null;
    weapon?: INodeItemSpec | string | null;
    wearable?: INodeItemSpec | string | null;
  };
  personality?: {
    traits: Array<WorldNpcPersonalityTrait>;
    background: WorldNpcBackground | Array<WorldNpcBackground>;
  };
  labels?: Array<string>;
  oneOf?: Array<INodeNpcPopulator> | Array<string>;
}

export type INodePopulator = INodeChildrenPopulator
  | INodeItemPopulator
  | INodeNpcPopulator;

export interface INodeRuleMatcher {
  hasType?: WorldNodeAreaType;
  hasLabel?: string;
  building?: {
    hasBuildingType: WorldNodeBuildingType;
  };
  room?: {
    hasRoomType: WorldNodeRoomType;
  };
  street?: {
    hasStreetType: WorldNodeStreetType;
  };
  settlement?: {
    hasSettlementType: WorldNodeSettlementType;
  };
  wilderness?: {
    hasWildernessType: WorldNodeWildernessType;
  };
  ancestor?: INodeRuleMatcher;
}

export interface INodePopulatorRule extends INodeRuleMatcher {
  id: string;
  // !!! ATTENTION! DO NOT USE {"oneOf": [ ... ]} or [...] FOR `apply`!!!
  apply: string;
  count: {
    min: number;
    max: number;
  };
  depth?: {
    min: number;
    max: number;
  };
  probability?: number;
}

Starting populators:

{{#each populator-collections}}
{{{name}}}
[
{{#each populators}}
{{{jsonData}}}{{#unless @last}},{{/unless}}
{{/each}}
]{{#unless @last}},{{/unless}}
{{/each}}

End of starting populators.

Starting rules:

{{#each rule-collections}}
{{{name}}}
[
{{#each rules}}
{{{jsonData}}}{{#unless @last}},{{/unless}}
{{/each}}
]{{#unless @last}},{{/unless}}
{{/each}}

End of starting rules.

Always respond with a JSON object, that looks like this:

{
  "populators": {
    "add": {
      "populators-file-key": [ ... populators to add ... ]
    },
    "change": {
      "populators-file-key": [ ... populators to change ... ]
    },
    "remove": {
      "populators-file-key": [ ... populators to remove ... ]
    }
  },
  "rules": {
    "add": {
      "rules-file-key": [ ... rules to add ... ]
    },
    "change": {
      "rules-file-key": [ ... rules to change ... ]
    },
    "remove": {
      "rules-file-key": [ ... rules to remove ... ]
    }
  }
}

For "populators-file-key", write the name of the populators JSON file you want to change. DO NOT ADD file names, that have no additional populators to add, change or remove. Feel free to add new files.

In the `populators to add` array, write the populator JSON objects, that are NEW AND NOT YET EXISTING. These will be added to the file.

In the `populators to change` array, write the populator JSON objects, that are EXISTING AND NEED TO BE CHANGED. These will be updated in the file.

In the `populators to remove` array, write the IDENTIFIER of the populator JSON objects, that are EXISTING AND NEED TO BE REMOVED. These will be removed from the file.

For "rules-file-key", write the name of the rules JSON file you want to change. DO NOT ADD file names, that have no additional rules to add, change or remove. Feel free to add new files.

In the `rules to add` array, write the rule JSON objects, that are NEW AND NOT YET EXISTING. These will be added to the file.

In the `rules to change` array, write the rule JSON objects, that are EXISTING AND NEED TO BE CHANGED. These will be updated in the file.

In the `rules to remove` array, write the IDENTIFIER of the rule JSON objects, that are EXISTING AND NEED TO BE REMOVED. These will be removed from the file.
